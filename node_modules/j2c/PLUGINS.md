# `j2c` Plugin author notes

A plugin can be an object, a function or an array of plugins (nested arrays are thus supported).

```JS
_j2c = j2c().use(
    {foo: 1}, 
    [
        {bar: 2},
        function(i) {
            i.baz = 3;
            return {qux: 4}
        }
    ]
)
```


Objects are used to non-destructively decorate the `j2c` instance. If a property is defined on both the instance and the plugin, the original field is preserved.

Functions are free to do whatever the please to the instance. If a function plugin returns an object, it is used as an object plugin.

In object plugins, properties starting with a `$` are not added to the instance. Instead, they may trigger custom behavior. Two special properties are currently supported: `$names` and `$filters`. 

- `$names` expects a class and animation names dictionary to (non-desrtuctively) extend the one of the instance.
- `$filter` expects a function that will wrap the buffer populating functions.

The `$filter` function recieves the buffer itself and the buffer setters, and is expected to return a new object with corresponding fields.

Filters are a bit hard to explain because they tap deeply into the innards of `j2c`. That was the best way I could add a reasonably powerful and efficient extension mechanism without blowing up the file size.

As `j2c` walks an object tree, it `.push()`es, on the fly,  parts of the sheets to a buffer (an array) that will be `.join('')`ed when done. 

The pushers object holds setters that wrap said pushing in different contexts: at-rules, selectors, declarations and closing braces.

```JS
{$filter: function (next) {
    return {
        x: function () {
            console.log(next.x(raw))
            console.log(next.x())
            return next.x()
        }, // the buffer
        a: function (rule, space, args, term) {
            console.log('at-rule', [rule, space, args, term])
            next.a(rule, space, args, term)
        },
        c: function()
    }
}}